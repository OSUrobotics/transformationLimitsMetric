* **Analysis**
  * getThresholds.m (*Function*): 
  * imageGenerator.m (*Script*): Loops through the object hand linking, drawing and saving an image for each combination.  See also: *linkFilenames.m*, *loadHandObject.m*
  * clusterStability.m (*Function*): Takes two indexes representing preped grasps, and outputs the number of times they are clustered togeter.  Can use either kmeans or DBScan clustering.  See also: *load4clustering.m*, *DBSCAN.m*
  * clusters2images.m (*Function*): Accepts the output from kmeans or DBscan as well as the names array from load4clustering and sorts images generated by imageGenerated into a specified directory based on how they were clustered.  See also: *DBSCAN.m*, *load4Clustering.m*, *imageGenerator.m*
  * load4clustering.m (*Function*): Creates an input matrix for kmeans or DBscan clustering.  Accepts a directory and a number of inputs (rows per step file in directory).  See also: *applySim2Data.m*
  * plotKmeans.m (*Script*): Runs kmeans on a specified set of data with a number of different cluster amounts to determine how many clusters is optimal.
* **ClusterOut**
* **handAndAlignment**
  * **hand**
  * **transforms**
  * obj_dict.csv: 
* ****Images****
* **Mesh Tools**
  * **File Readers**
    * read_ply.m (*Function*): Function from [Toolbox Graph] (https://www.mathworks.com/matlabcentral/fileexchange/5355-toolbox-graph/) that accepts a ply file and outputs two Nx3 matrices, one for vertex coordinates and one for face correlations.
    * stlGetFormat.m (*Function*): A dependancy of stlRead, from the same toolbox.  Determines if an STL file is binary or ascii.  See also: *stlRead.m*
    * stlRead.m (*Function*): Function from [STL File Reader] (https://www.mathworks.com/matlabcentral/fileexchange/22409-stl-file-reader) that accepts an stl file and outputs two Nx# matrices, one for vertex coorinates and one for face correlations.  See also: *stlGetFormat.m*, *stlReadBinary.m*, *stlReadAscii*
    * stlReadAscii.m (*Function*): A dependancy of stlRead, from the same toolbox.  Reads an ascii stl file into a vertex matrix and a face matrix.  See also: *stlRead.m*
    * stlReadBinary.m (*Function*): A dependancy of stlRead, from the same toolbox.  Reads a binary stl file into a vertex matrix and a face matrix. See also:  *stlRead.m*
    * stlSlimVerts.m (*Function*): -- Is this even used anywhere? --
  * **File Writers**
    * write_ply.m (*Function*): -- Do we use this either? --
  * getBBcenter.m (*Function*): Accepts a set of points and returns the point at the center of the bounding box.
  * getCentroidMesh.m (*Function*): Accepts a set of points and returns the centroid point.
  * rotateMesh.m (*Function*): -- Might we consider rewriting the things that use this and removing these? --
  * translateMesh.m (*Function*): -- Might we consider rewriting the things that use this and removing these? --
  * trimeshSurfaceArea.m (*Function*): Function from [geom3d] (https://www.mathworks.com/matlabcentral/fileexchange/24484-geom3d/) that calculateds the surface area of a model.  This is used in collision calculations.  See also: *getCollisionVoxelVoxel.m*
  * vectorCross3d.m (*Function*): A dependancy of trimeshSurfaceArea that calculates vector cross product faster than matlab internal cross product.  It is from the same toolbox as trimeshSurfaceArea.  See also: *trimeshSurfaceArea.m*
* **Output**
* **Readers and Visualizations**
  * **PresentationImages**
  * plotAxesArrows.m (*Function*): Visualizes the transformations in *saveTrajectories.m* as RGB axes markers tracking each step location and orientation. 
  * visualizeTransformations.m (*Function*): 
* **sampleSTLs**
* **Simulation Sections**
  * **Collision Detection**
     * **Dependencies**
        * VOXELISE.m (*Function*): Function from [Mesh voxelisation](https://www.mathworks.com/matlabcentral/fileexchange/27390-mesh-voxelisation) toolkit that takes the vertices and faces from an STL and generates a binary 3D image of the points inside the mesh. Outputs a matrix, which is converted into coordinates through either *getVoxelValues.m* (for the hand STLs) or *getVoxelisedVerts.m* (for the object STLs), with each type being used in *getCollisionVoxelVoxel.m*. See also: *getVoxelValues.m*, *getVoxelisedVerts.m*, *getCollisionVoxelVoxel.m*
        * intriangulation.m (*Function*): Old function that calculated the intersection of points (hand voxels) with a mesh (object vertices and faces). Do not use, replaced by *getCollisionVoxelVoxel.m*. See also: *getCollisionValues.m*, *getPercentCollision.m*, *getPercentCollisionWithVerts.m*, *getCollisionVoxelVoxel.m*
     * getCollisionValues.m (*Function*): Old function that used *intriangulation.m* to calculate volume of intersection. Was replaced by *getCollisionVoxelVoxel.m*. See also: *getCollisionVoxelVoxel.m*, *intriangulation.m*
     * getCollisionVoxelVoxel.m (*Function*): This function calculates the intersection of two voxel sets, the hand set generated from *getVoxelValues.m* and the object set from *getVoxelisedVerts.m*, while also factoring in the surface area and intersection of object surface points with the hand. See also: *getVoxelisedVerts.m*, *getVoxelValues.m*, *runSimFun.m*
     * getPercentCollision.m (*Function*): Old function that used *intriangulation.m* to to calculate volume of intersection and percentage of intersection. Was replaced by *getCollisionVoxelVoxel.m*. See also: *getCollisionVoxelVoxel.m*, *intriangulation.m*
     * getPercentCollisionWithVerts.m (*Function*): Old function that used *intriangulation.m* to calculate volume of intersection and percentage of intersection, factoring in surface vertices as well. Was replaced by *getCollisionVoxelVoxel.m*. See also: *getCollisionVoxelVoxel.m*, *intriangulation.m*
     * getVoxelisedVerts.m (*Function*): Returns an Nx3 matrix of voxel coordinate data based on a given mesh and resolution.  See also: *VOXELISE.m*
     * getVoxelValues.m (*Function*): Returns an Nx4 matrix of voxel coordinate data with a logical value.  The first three columns contain x,y,z position and the fourth contains a 1 for inside the given mesh and 0 for outside.  See also: *VOXELISE.m*
  * **Generate Transformations**
    * **Dependencies**
      * SpiralSampleSphere.m (*Function*): Function from [Suite of functions to perform uniform sampling of a sphere](http://www.mathworks.com/matlabcentral/fileexchange/37004-suite-of-functions-to-perform-uniform-sampling-of-a-sphere) that generates a given number of point coordinates on a unit sphere using a "spiral phyllotaxis" method (Sunflower magic). See also: *generateTrajectories.m*
      * stlPlot.m (*Function*): Function from [stlTools](https://www.mathworks.com/matlabcentral/fileexchange/51200-stltools) modified to plot vertices as well. Plots a stl as stored with vertices and faces. See also: *stlPlotWColor.m*
      * stlPlotWColor.m (*Function*): A modified *stlPlot.m* that accepts an extra value (typically collision volume), which is the percentage of red added to the normal color of the object (high values will add more red to the gray). See also: *stlPlot.m*
    * applySavedTransformations.m (*Function*): Takes in a list of object points and the all-values transformation matrix generated by *saveTrajectories.m* and applies the transformations to the points, outputting a large set of all of the points, transformed to all of the steps on the way to the locations and orientations created by *generateTrajectories.m*, in a multi-dimensional array. See also: *saveTrajectories.m*, *generateTrajectories.m*, *runSimFun.m*
    * generateTrajectories.m (*Function*): Uses *SpiralSampleSphere.m* to generate translation vectors and rotation axes, then takes an input for the amount of rotation around each axis and gets all possible combinations of each, with an added no-movement case. See also: *saveTrajectories.m*, *SpiralSampleSphere.m*
    * matrix2values.m (*Function*): Converts a set of 4x4 transformation matrices from *trajectoryStepsEXPM.m* into *x,y,z* translation vectors and a rotation quaternion, to be stored alongside the collision volume in **Output**. See also: *saveTrajectories.m*
    * oldTrajectoryStepsEXPM.m (*Function*): An older version of trajectoryStepsEXPM that directly applied the transformations to the points instead of saving the matrices. See also: *trajectoryStepsEXPM.m*, *oldTrajectoryStepsEuler.m*
    * oldTrajectoryStepsEuler.m (*Function*): An older version of trajectoryStepsEuler that directly applied the transformations to the points instead of saving the matrices. See also: *trajectoryStepsEuler.m*, *oldTrajectoryStepsEXPM.m*
    * saveTrajectories.m (*Function*): Calls *trajectoryStepsEXPM.m* to generate interpolated paths to the coordinates and orientations specified in 
    * trajectoryStepsEXPM.m (*Function*): Creates a set of interpolated 4x4 transformation matrices along a set number of steps from the origin to the locations and orientations generated with *generateTrajectories.m*. Uses EXPM, the equivalent of a transformation matrix integral rather than the approximation used in *trajectoryStepsEuler.m*. See also: *saveTrajectories.m*, *generateTrajectories.m*, *trajectoryStepsEuler.m*
    * trajectoryStepsEuler.m (*Function*): An alternative to *trajectoryStepsEXPM.m* that uses the Euler to iterate over small transformations instead of EXPM. See also: *trajectoryStepsEXPM.m*
  * runSimFun.m (*Function*): 
* applySim2data.m (*Script*): **This is the main script to run the simulation.** It loads in or generates the stored transformations (*transformationStored.mat*), all grasp-object sets (**handAndAlignment**), calls *runSimFun.m*, and saves the intersection volume data to **Output**. See also: *runSimFun.m*, *transformationStored.mat*, *pathMapping.csv*, **Output**, **handAndAlignment**
* filenamesFromComponents.m (*Function*): Takes in the object, subject, grasp, and optimal or extreme string and outputs filenames for the hand, object, transformations, and output data, with optional step numbers or sprintf input format. See also: *pathMapping.csv*, *linkFilenames.m*
* linkFilenames.m (*Function*): Generates *pathMapping.csv*. Reads the **handAndAlignment/transforms** directory and scrapes the filename, then calls *filenamesFromComponents.m* and saves the results to a given file (*pathMapping.csv*). See also: *filenamesFromComponents.m*, *pathMapping.csv*
* loadHandObject.m (*Function*): Given a hand filepath, object vertices, and information about the hand centering, positions and scales the object and hand to fit in the origin, normalized to the unit sphere. Called by *applySim2data.m*.
* makeTransformationValuesOld.m (*Function*): An old function that used a different method for generating transformation values, using icosahedron sphere point generation, replaced by *generateTrajectories.m* as it did not allow the direct selection of an arbitrary number of values.
* pathMapping.csv: A list that links the filenames of the transformations, objects, hands, and outputs with the object, subject, grasp, and optimal or extreme string. Each line is an individual and unique grasp. See also: *filenamesFromComponents.m*, *linkFilenames.m*
* simpleHand.stl: An old example hand used for initial testing. Unimportant, unused now.
* transformationStored.mat: The saved transformation values and 4x4 matrices for every transformation direction and orientation, along with the settings used to create them. Generated by *saveTrajectories.m* and associated code. See also: *saveTrajectories.m*