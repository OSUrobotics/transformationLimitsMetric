* **Mesh Tools**
  * **File Readers**
    * read_ply.m (*Function*): Function from [Toolbox Graph] (https://www.mathworks.com/matlabcentral/fileexchange/5355-toolbox-graph/) that accepts a ply file and outputs two Nx3 matrices, one for vertex coordinates and one for face correlations.
    * stlGetFormat.m (*Function*): A dependancy of stlRead, from the same toolbox.  Determines if an STL file is binary or ascii.  See also: *stlRead.m*
    * stlRead.m (*Function*): Function from [STL File Reader] (https://www.mathworks.com/matlabcentral/fileexchange/22409-stl-file-reader) that accepts an stl file and outputs two Nx# matrices, one for vertex coorinates and one for face correlations.  See also: *stlGetFormat.m*, *stlReadBinary.m*, *stlReadAscii*
    * stlReadAscii.m (*Function*): A dependancy of stlRead, from the same toolbox.  Reads an ascii stl file into a vertex matrix and a face matrix.  See also: *stlRead.m*
    * stlReadBinary.m (*Function*): A dependancy of stlRead, from the same toolbox.  Reads a binary stl file into a vertex matrix and a face matrix. See also:  *stlRead.m*
    * stlSlimVerts.m (*Function*): -- Is this even used anywhere? --
  * **File Writers**
    * write_ply.m (*Function*): -- Do we use this either? --
  * getBBcenter.m (*Function*): Accepts a set of points and returns the point at the center of the bounding box.
  * getCentroidMesh.m (*Function*): Accepts a set of points and returns the centroid point.
  * rotateMesh.m (*Function*): -- Might we consider rewriting the things that use this and removing these? --
  * translateMesh.m (*Function*): -- Might we consider rewriting the things that use this and removing these? --
  * trimeshSurfaceArea.m (*Function*): Function from [geom3d] (https://www.mathworks.com/matlabcentral/fileexchange/24484-geom3d/) that calculateds the surface area of a model.  This is used in collision calculations.  See also: *getCollisionVoxelVoxel.m*
  * vectorCross3d.m (*Function*): A dependancy of trimeshSurfaceArea that calculates vector cross product faster than matlab internal cross product.  It is from the same toolbox as trimeshSurfaceArea.  See also: *trimeshSurfaceArea.m*
* **sampleSTLs**
* **Simulation Sections**
  * **Collision Detection**
     * **Dependencies**
        * VOXELISE.m (*Function*): Function from [Mesh voxelisation](https://www.mathworks.com/matlabcentral/fileexchange/27390-mesh-voxelisation) toolkit that takes the vertices and faces from an STL and generates a binary 3D image of the points inside the mesh. Outputs a matrix, which is converted into coordinates through either *getVoxelValues.m* (for the hand STLs) or *getVoxelisedVerts.m* (for the object STLs), with each type being used in *getCollisionVoxelVoxel.m*. See also: *getVoxelValues.m*, *getVoxelisedVerts.m*, *getCollisionVoxelVoxel.m*
        * intriangulation.m (*Function*): Old function that calculated the intersection of points (hand voxels) with a mesh (object vertices and faces). Do not use, replaced by *getCollisionVoxelVoxel.m*. See also: *getCollisionValues.m*, *getPercentCollision.m*, *getPercentCollisionWithVerts.m*, *getCollisionVoxelVoxel.m*
     * getCollisionVoxelVoxel.m (*Function*): 
     * getVoxelisedVerts.m (*Function*): Returns an Nx3 matrix of voxel coordinate data based on a given mesh and resolution.  See also: *VOXELISE.m*
     * getVoxelValues.m (*Function*): Returns an Nx4 matrix of voxel coordinate data with a logical value.  The first three columns contain x,y,z position and the fourth contains a 1 for inside the given mesh and 0 for outside.  See also: *VOXELISE.m*
  * **Generate Transformations**
    * **Dependencies**
      * SpiralSampleSphere.m (*Function*): Function from [Suite of functions to perform uniform sampling of a sphere](http://www.mathworks.com/matlabcentral/fileexchange/37004-suite-of-functions-to-perform-uniform-sampling-of-a-sphere) that generates a given number of point coordinates on a unit sphere using a "spiral phyllotaxis" method (Sunflower magic). See also: *generateTrajectories.m*
      * stlPlot.m (*Function*): Function from [stlTools](https://www.mathworks.com/matlabcentral/fileexchange/51200-stltools) modified to plot vertices as well. Plots a stl as stored with vertices and faces. See also: *stlPlotWColor.m*
    * applySavedTransformations.m (*Function*): Takes in a list of object points and the all-values transformation matrix generated by *saveTrajectories.m* and applies the transformations to the points, outputting a large set of all of the points, transformed to all of the steps on the way to the locations and orientations created by *generateTrajectories.m*, in a multi-dimensional array. See also: *saveTrajectories.m*, *generateTrajectories.m*, *runSimFun.m*
    * generateTrajectories.m (*Function*): Uses *SpiralSampleSphere.m* to generate translation vectors and rotation axes, then takes an input for the amount of rotation around each axis and gets all possible combinations of each, with an added no-movement case. See also: *saveTrajectories.m*, *SpiralSampleSphere.m*
    * matrix2values.m (*Function*): Converts a set of 4x4 transformation matrices from *trajectoryStepsEXPM.m* into *x,y,z* translation vectors and a rotation quaternion, to be stored alongside the collision volume in **Output**. See also: *saveTrajectories.m*
    * saveTrajectories.m (*Function*): Calls *trajectoryStepsEXPM.m* to generate interpolated paths to the coordinates and orientations specified in 
    * trajectoryStepsEXPM.m (*Function*): Creates a set of interpolated 4x4 transformation matrices along a set number of steps from the origin to the locations and orientations generated with *generateTrajectories.m*. Uses EXPM, the equivalent of a transformation matrix integral rather than the approximation used in *trajectoryStepsEuler.m*. See also: *saveTrajectories.m*, *generateTrajectories.m*, *trajectoryStepsEuler.m*
    * trajectoryStepsEuler.m (*Function*): An alternative to *trajectoryStepsEXPM.m* that uses the Euler to iterate over small transformations instead of EXPM. See also: *trajectoryStepsEXPM.m*
  * runSimFun.m (*Function*): 
* applySim2data.m (*Script*): **This is the main script to run the simulation.** It loads in or generates the stored transformations (*transformationStored.mat*), all grasp-object sets (**handAndAlignment**), calls *runSimFun.m*, and saves the intersection volume data to **Output**. See also: *runSimFun.m*, *transformationStored.mat*, *pathMapping.csv*, **Output**, **handAndAlignment**
* filenamesFromComponents.m (*Function*): Takes in the object, subject, grasp, and optimal or extreme string and outputs filenames for the hand, object, transformations, and output data, with optional step numbers or sprintf input format. See also: *pathMapping.csv*, *linkFilenames.m*
* linkFilenames.m (*Function*): Generates *pathMapping.csv*. Reads the **handAndAlignment/transforms** directory and scrapes the filename, then calls *filenamesFromComponents.m* and saves the results to a given file (*pathMapping.csv*). See also: *filenamesFromComponents.m*, *pathMapping.csv*
* loadHandObject.m (*Function*): Given a hand filepath, object vertices, and information about the hand centering, positions and scales the object and hand to fit in the origin, normalized to the unit sphere. Called by *applySim2data.m*.
* makeTransformationValuesOld.m (*Function*): An old function that used a different method for generating transformation values, using icosahedron sphere point generation, replaced by *generateTrajectories.m* as it did not allow the direct selection of an arbitrary number of values.
